@page "/dynamic-templates"
@using NCalc
@using Sunduk.PWA.Infrastructure.DynamicTemplatesData 
@using BlazorDownloadFile
@using System.Text.Json
@using System.Text
@using Sunduk.PWA.Infrastructure.Extensions
@using System.Threading
@using System.IO
@using BlazorTextEditor
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<style>
    .file-upload-input {
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
        z-index: 10;
        opacity: 0;
    }

    .variable-buttons {
        display: flex;
        flex-direction: column;
        gap: 2px;
        padding-top: 8px;
    }
</style>

<MudPopover Open="@(LocalStorageIsWorking || LocalStorageWorkCompleted)" AnchorOrigin="Origin.TopCenter">
    @if (LocalStorageIsWorking)
    {
        <MudProgressCircular Color="Color.Primary" Style="height:30px;width:30px;" Indeterminate="true" Class="mx-2 mt-2 mb-n0" />
    }
    @if (LocalStorageWorkCompleted)
    {
        <MudIcon Color="Color.Primary" Style="height:30px;width:30px;" Icon="@Icons.Material.Outlined.DoneAll" Class="mx-2 mt-2 mb-n0" />
    }
</MudPopover>

<MudToolBar Dense="true">
    <MudButton Variant="Variant.Outlined" OnClick="AddTemplate" EndIcon="@Icons.Material.Outlined.PostAdd" Size="Size.Small">Добавить шаблон</MudButton>
    <MudFileUpload T="IReadOnlyList<IBrowserFile>" Class="flex-grow-1"
                   @ref="@_fileUpload"
                   OnFilesChanged="OnInputFileChanged"
                   AppendMultipleFiles
                   Hidden="@false"
                   InputClass="file-upload-input"
                   tabindex="-1"
                   @ondrop="@ClearDragClass"
                   @ondragenter="@SetDragClass"
                   @ondragleave="@ClearDragClass"
                   @ondragend="@ClearDragClass">
        <ActivatorContent>
            <MudPaper Outlined="true" Class="@_dragClass">
                <MudSpacer />
                <MudFileUpload T="IBrowserFile" Accept=".json" FilesChanged="UploadTemplates">
                    <ActivatorContent>
                        <MudSpacer />
                        <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Outlined.FileUpload" />
                    </ActivatorContent>
                </MudFileUpload>
            </MudPaper>
        </ActivatorContent>
    </MudFileUpload>
    <MudIconButton Variant="Variant.Text" Class="ma-0 pa-0" OnClick="DownloadTemplatesAsync" Icon="@Icons.Material.Outlined.FileDownload" />
</MudToolBar>

<MudExpansionPanels MultiExpansion="true" Square="true">
    @foreach (var template in templates)
    {
        <MudExpansionPanel>
            <TitleContent>
                <MudGrid Class="align-start d-flex" Spacing="1">
                    <MudText Class="mt-1 mb-n1">@template.Name</MudText>
                    <MudSpacer />
                    <MudButtonGroup Class="mx-3 mt-0 mb-n1" Variant="Variant.Outlined">
                        @if (templates.IndexOf(template) < templates.Count - 1)
                        {
                            <MudIconButton Variant="Variant.Text" OnClick="() => MoveDown(template)" Icon="@Icons.Material.Outlined.ArrowDropDown" />
                        }
                        @if (templates.IndexOf(template) > 0)
                        {
                            <MudIconButton Variant="Variant.Text" OnClick="() => MoveUp(template)" Icon="@Icons.Material.Outlined.ArrowDropUp" />
                        }
                        <MudIconButton Variant="Variant.Text" OnClick="() => OpenRenameDialogAsync(template)" Icon="@Icons.Material.Outlined.DriveFileRenameOutline" />
                        <MudIconButton Variant="Variant.Text" OnClick="() => OpenDeleteDialogAsync(template)" Icon="@Icons.Material.Outlined.Delete" Color="Color.Error" />
                    </MudButtonGroup>
                </MudGrid>
            </TitleContent>
            <ChildContent>
                <MudToolBar Dense="true">
                    <MudIconButton Variant="Variant.Text" Class="my-0 py-0" OnClick="() => { Calculate(template); PersistAsync().AndForget(); }" Icon="@Icons.Material.Outlined.Calculate" Color="Color.Primary" />
                    <MudSpacer />
                    <MudIconButton Variant="Variant.Text" Class="my-0 py-0" OnClick="() => { template.Variables.Add(new VariableDefinition()); PersistAsync().AndForget(); }" Icon="@Icons.Material.Outlined.PlaylistAdd" />
                    <MudDivider Vertical="true" />
                    <MudIconButton Variant="Variant.Text" Class="my-0 py-0" OnClick="() => DownloadTemplateAsync(template)" Icon="@Icons.Material.Outlined.Download" />
                </MudToolBar>
                <MudGrid Spacing="1" Class="ma-0">
                    <MudItem xs="6">
                        <MudTextField T="string"
                                      Label="Заготовка"
                                      Style="font-family: 'Roboto Mono', monospace; font-size: 10px;"
                                      Variant="Variant.Filled"
                                      AutoGrow="true"
                                      @bind-Value="@template.Content"
                                      Immediate="true"
                                      Lines="@(template.Content.Count(c => c == '\n') + 1)"
                                       />
                        <MudTextField T="string"
                                      Label="Результат"
                                      Style="font-family: 'Roboto Mono', monospace; font-size: 12px;"
                                      Variant="Variant.Filled"
                                      AutoGrow="true"
                                      Immediate="true"
                                      Lines="@(template.Result.Count(c => c == '\n') + 1)"
                                      Value="template.Result"
                                      ReadOnly="true" />
                    </MudItem>
                    <MudItem xs="6">
                        <MudField Label="Переменные" Variant="Variant.Filled" Underline="false" InnerPadding="false" FullWidth="true">
                            <MudList T="string" Dense="true">

                                @foreach (var variable in @template.Variables)
                                {
                                    var index = template.Variables.IndexOf(variable);
                                    <MudGrid Spacing="0" Class="ma-0 pa-0 align-center d-flex flex-row flex-nowrap">
                                        <MudItem>
                                            <MudTextField Margin="Margin.None"
                                                          @bind-Text="variable.Name"
                                                          Error="variable.HasError"
                                                          ErrorText="@variable.Error"
                                                          Placeholder="Имя"
                                                          Variant="Variant.Text"
                                                          Immediate="true"
                                                          Class="pt-0"
                                                          Style="font-family: 'Roboto Mono', monospace; font-size: 12px;" />
                                        </MudItem>

                                        <MudItem Class="px-1">
                                            <MudText Style="font-size: 18px; line-height: 1.2">:</MudText>
                                        </MudItem>

                                        <MudItem Class="flex-grow-1 flex-shrink-1">
                                            <MudTextField Margin="Margin.None"
                                                          @bind-Text="variable.Expression"
                                                          Placeholder="Значение"
                                                          Variant="Variant.Text"
                                                          Class="pt-0"
                                                          Style="font-family: 'Roboto Mono', monospace; font-size: 12px;" />
                                        </MudItem>

                                        <MudItem Class="variable-buttons">
                                            <MudIconButton Variant="Variant.Text"
                                                           Size="Size.Small"
                                                           Disabled="@(index == 0)"
                                                           OnClick="() => MoveVariableUp(template, variable)"
                                                           Icon="@Icons.Material.Outlined.ArrowDropUp" />
                                            <MudIconButton Variant="Variant.Text"
                                                           Size="Size.Small"
                                                           Disabled="@(index == template.Variables.Count - 1)"
                                                           OnClick="() => MoveVariableDown(template, variable)"
                                                           Icon="@Icons.Material.Outlined.ArrowDropDown" />
                                        </MudItem>

                                        <MudItem>
                                            <MudIconButton Variant="Variant.Text"
                                                           Size="Size.Small"
                                                           Class="mt-1"
                                                           OnClick="() => OpenDeleteDialogAsync(template, variable)"
                                                           Icon="@Icons.Material.Outlined.Delete"
                                                           Color="Color.Error" />
                                        </MudItem>
                                    </MudGrid>
                                }
                            </MudList>
                        </MudField>
                    </MudItem>
                </MudGrid>
            </ChildContent>
        </MudExpansionPanel>
    }
</MudExpansionPanels>

@code {
    // =====================================
    // ВНЕДРЕНИЕ ЗАВИСИМОСТЕЙ
    // =====================================
    [Inject] public IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

    // =====================================
    // СОСТОЯНИЕ КОМПОНЕНТА И ПЕРЕМЕННЫЕ
    // =====================================
    private const string RadianToDegreeFunction = "Deg";
    private const string DegreeToRadianFunction = "Rad";
    private const string DefaultDragClass = "border-2 border-dashed align-start d-flex object-fill mud-theme-transparent ma-3";
    private string _dragClass = DefaultDragClass;
    private readonly List<string> _fileNames = new();
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;
    private readonly SemaphoreSlim _persistSemaphore = new(1, 1);
    public List<TemplateDefinition> templates { get; set; } = new();
    public bool LocalStorageIsWorking { get; set; }
    public bool LocalStorageWorkCompleted { get; set; }
    private readonly Dictionary<string, string> _variableMapping = new Dictionary<string, string>();
    public List<string> CalculationErrors { get; set; } = new();

    // =====================================
    // ИНИЦИАЛИЗАЦИЯ КОМПОНЕНТА
    // =====================================
    protected override async Task OnInitializedAsync()
    {
        templates = await LocalStorage.GetItemAsync<List<TemplateDefinition>>(nameof(templates))
                ?? new List<TemplateDefinition>();
        StateHasChanged();
    }

    // =====================================
    // УПРАВЛЕНИЕ ШАБЛОНАМИ
    // =====================================
    private void AddTemplate()
    {
        templates.Add(new TemplateDefinition() { Name = $"Новый шаблон", Variables = new() { new VariableDefinition() } });
        PersistAsync().AndForget();
    }

    private void MoveUp(TemplateDefinition template)
    {
        var i = templates.IndexOf(template);
        templates.Remove(template);
        templates.Insert(i - 1, template);
        StateHasChanged();
        PersistAsync().AndForget();
    }

    private void MoveDown(TemplateDefinition template)
    {
        var i = templates.IndexOf(template);
        templates.Remove(template);
        templates.Insert(i + 1, template);
        StateHasChanged();
        PersistAsync().AndForget();
    }

    // =====================================
    // МЕТОДЫ ПЕРЕМЕЩЕНИЯ ПЕРЕМЕННЫХ ВНУТРИ ШАБЛОНА
    // =====================================
    private void MoveVariableUp(TemplateDefinition template, VariableDefinition variable)
    {
        var index = template.Variables.IndexOf(variable);
        if (index > 0)
        {
            template.Variables.RemoveAt(index);
            template.Variables.Insert(index - 1, variable);
            PersistAsync().AndForget();
            StateHasChanged();
        }
    }

    private void MoveVariableDown(TemplateDefinition template, VariableDefinition variable)
    {
        var index = template.Variables.IndexOf(variable);
        if (index < template.Variables.Count - 1)
        {
            template.Variables.RemoveAt(index);
            template.Variables.Insert(index + 1, variable);
            PersistAsync().AndForget();
            StateHasChanged();
        }
    }

    // =====================================
    // РАБОТА С ЛОКАЛЬНЫМ ХРАНИЛИЩЕМ
    // =====================================
    private async Task PersistAsync()
    {
        await _persistSemaphore.WaitAsync();
        try
        {
            LocalStorageWorkCompleted = false;
            LocalStorageIsWorking = true;
            StateHasChanged();

            await LocalStorage.SetItemAsync(nameof(templates), templates);

            StateHasChanged();
            LocalStorageWorkCompleted = true;
            LocalStorageIsWorking = false;
            StateHasChanged();

            await Task.Delay(1000);
            LocalStorageWorkCompleted = false;
            StateHasChanged();
        }
        finally
        {
            _persistSemaphore.Release();
        }
    }

    // =====================================
    // ЭКСПОРТ ШАБЛОНОВ
    // =====================================
    private async Task DownloadTemplatesAsync()
    {
        if (templates.Count < 1)
        {
            Snackbar.Add("Нечего скачивать", Severity.Warning);
            return;
        }
        var json = JsonSerializer.Serialize(templates, new JsonSerializerOptions { WriteIndented = true });
        var bytes = Encoding.UTF8.GetBytes(json);
        await BlazorDownloadFileService.DownloadFile("sunduk-dt-all.json", bytes, "application/json");
    }

    private async Task DownloadTemplateAsync(TemplateDefinition template)
    {
        var json = JsonSerializer.Serialize(new List<TemplateDefinition>() { template }, new JsonSerializerOptions { WriteIndented = true });
        var bytes = Encoding.UTF8.GetBytes(json);
        await BlazorDownloadFileService.DownloadFile($"sunduk-dt-{template.Name}.json", bytes, "application/json");
    }

    // =====================================
    // ИМПОРТ ШАБЛОНОВ
    // =====================================

    private async Task UploadTemplates(IBrowserFile file)
    {
        using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024);
        using var reader = new StreamReader(stream);
        var json = await reader.ReadToEndAsync();

        List<TemplateDefinition>? loaded = null;

        var options = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };



        try
        {
            loaded = JsonSerializer.Deserialize<List<TemplateDefinition>>(json, options);
        }
        catch (JsonException ex)
        {
            Snackbar.Add($"Ошибка чтения JSON: {ex.Message}", Severity.Error);
            return;
        }

        if (loaded == null || loaded.Count == 0)
        {
            Snackbar.Add("Ошибка: не удалось загрузить ни одного шаблона из файла", Severity.Error);
            return;
        }

        if (templates.Any())
        {
            var result = await DialogService.ShowMessageBox(
                "Импорт шаблонов",
                $"Добавить шаблоны: {loaded.Count} шт. к существующим или заменить всё?",
                yesText: "Добавить", noText: "Заменить", cancelText: "Отмена");

            switch (result)
            {
                case true:
                    templates.AddRange(loaded);
                    break;
                case false:
                    templates = loaded;
                    break;
                default:
                    return;
            }
        }
        else
        {
            templates = loaded;
        }

        PersistAsync().AndForget();
        StateHasChanged();
    }

    // =====================================
    // ЛОГИКА ВЫЧИСЛЕНИЯ ШАБЛОНОВ
    // =====================================
    private void Calculate(TemplateDefinition tpl)
    {
        try
        {
            CalculationErrors.Clear();
            _variableMapping.Clear();

            var values = new Dictionary<string, double>();
            var maxIter = tpl.Variables.Count * 2;
            var currentIter = 0;
            bool hasProgress;

            int mappingCounter = 0;
            foreach (var v in tpl.Variables.Where(x => !string.IsNullOrWhiteSpace(x.Name)))
            {
                if (ContainsCyrillic(v.Name) && !_variableMapping.ContainsKey(v.Name))
                {
                    _variableMapping[v.Name] = $"var_{mappingCounter++}";
                }
            }

            do
            {
                hasProgress = false;
                var initialCount = values.Count;

                foreach (var v in tpl.Variables)
                {
                    if (string.IsNullOrWhiteSpace(v.Name) || string.IsNullOrWhiteSpace(v.Expression))
                        continue;

                    if (values.ContainsKey(v.Name))
                        continue;

                    try
                    {
                        string processedExpression = ProcessExpressionForNCalc(v.Expression);

                        var expr = new Expression(processedExpression.Replace(',', '.'), ExpressionOptions.IgnoreCaseAtBuiltInFunctions | ExpressionOptions.CaseInsensitiveStringComparer);

                        expr.Functions[DegreeToRadianFunction] = (args) =>
                        {
                            if (args.Count() > 1) ThrowLogged<ArgumentOutOfRangeException>($"Слишком много аргументов для функции {DegreeToRadianFunction}");
                            double d = args[0].Evaluate() switch
                            {
                                double dd => dd,
                                int ii => ii,
                                long ll => ll,
                                string ss => ToDouble(ss.Replace(',', '.')),
                                _ => throw new ArgumentException($"Неподдерживаемый тип: {args?.GetType()}")
                            };
                            return d * Math.PI / 180;
                        };

                        expr.Functions[RadianToDegreeFunction] = (args) =>
                        {
                            if (args.Count() > 1) ThrowLogged<ArgumentOutOfRangeException>($"Слишком много аргументов для функции {RadianToDegreeFunction}");
                            double d = args[0].Evaluate() switch
                            {
                                double dd => dd,
                                int ii => ii,
                                long ll => ll,
                                string ss => ToDouble(ss.Replace(',', '.')),
                                _ => ThrowLogged<ArgumentException>($"Неподдерживаемый тип: {args?.GetType()}"),
                            };
                            return d * 180 / Math.PI;
                        };

                        foreach (var kv in values)
                        {
                            string paramName = GetMappedName(kv.Key);
                            expr.Parameters[paramName] = kv.Value;
                        }

                        if (expr.HasErrors())
                            continue;

                        var raw = expr.Evaluate();
                        double d = raw switch
                        {
                            double dd => dd,
                            int ii => ii,
                            long ll => ll,
                            _ => ThrowLogged<ArgumentException>($"Неподдерживаемый тип: {raw?.GetType()}"),
                        };

                        values[v.Name] = d;
                    }
                    catch
                    {
                        continue;
                    }
                }

                hasProgress = values.Count > initialCount;
                currentIter++;

                if (currentIter >= maxIter)
                {
                    var validUnresolved = tpl.Variables
                        .Where(v => !string.IsNullOrWhiteSpace(v.Name) &&
                                   !string.IsNullOrWhiteSpace(v.Expression) &&
                                   !values.ContainsKey(v.Name))
                        .ToList();

                    if (validUnresolved.Any())
                    {
                        var unresolvedNames = string.Join(", ", validUnresolved.Select(v => $"{v.Name}: {v.Expression}"));
                        throw new Exception($"Не удалось вычислить переменные (возможно, циклическая зависимость или неопределенные переменные): {unresolvedNames}");
                    }
                    break;
                }
            }
            while (hasProgress && values.Count < tpl.Variables.Count(v => !string.IsNullOrWhiteSpace(v.Name) && !string.IsNullOrWhiteSpace(v.Expression)));

            var validNotResolved = tpl.Variables
                .Where(v => !string.IsNullOrWhiteSpace(v.Name) &&
                           !string.IsNullOrWhiteSpace(v.Expression) &&
                           !values.ContainsKey(v.Name))
                .ToList();

            if (validNotResolved.Any())
            {
                var notResolvedNames = string.Join(", ", validNotResolved.Select(v => $"{v.Name}: {v.Expression}"));
                throw new Exception($"Не удалось вычислить переменные: {notResolvedNames}\n{string.Join("\n\n", CalculationErrors)}");
            }

            tpl.Result = System.Text.RegularExpressions.Regex
                .Replace(tpl.Content, @"\{(.*?)\}", m =>
                {
                    try
                    {
                        string processedExpression = ProcessExpressionForNCalc(m.Groups[1].Value);

                        var sub = new Expression(processedExpression.Replace(',', '.'), ExpressionOptions.IgnoreCaseAtBuiltInFunctions | ExpressionOptions.CaseInsensitiveStringComparer);

                        foreach (var kv in values)
                        {
                            string paramName = GetMappedName(kv.Key);
                            sub.Parameters[paramName] = kv.Value;
                        }

                        if (sub.HasErrors())
                            return "[?]";

                        var r = sub.Evaluate();
                        return r is double d ? d.ToString("0.###").Replace(',', '.') :
                               r is int i ? i.ToString() :
                               r is long l ? l.ToString() :
                               r?.ToString() ?? "[?]";
                    }
                    catch
                    {
                        return "[?]";
                    }
                });
        }
        catch (Exception ex)
        {
            Snackbar.Configuration.PositionClass = Defaults.Classes.Position.TopCenter;
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private string ProcessExpressionForNCalc(string expression)
    {
        if (string.IsNullOrWhiteSpace(expression))
            return expression;

        string result = expression;

        var cyrillicVariables = _variableMapping.Keys
            .OrderByDescending(name => name.Length)
            .ToList();

        foreach (var originalName in cyrillicVariables)
        {
            var asciiName = _variableMapping[originalName];

            string pattern = @"(?<![а-яА-ЯёЁa-zA-Z0-9_])" +
                            System.Text.RegularExpressions.Regex.Escape(originalName) +
                            @"(?![а-яА-ЯёЁa-zA-Z0-9_])";

            result = System.Text.RegularExpressions.Regex.Replace(result, pattern, asciiName);
        }

        return result;
    }

    private string GetMappedName(string originalName)
    {
        return _variableMapping.ContainsKey(originalName) ? _variableMapping[originalName] : originalName;
    }

    private bool ContainsCyrillic(string text)
    {
        if (string.IsNullOrEmpty(text))
            return false;

        return text.Any(c => (c >= 'а' && c <= 'я') || (c >= 'А' && c <= 'Я') || c == 'ё' || c == 'Ё');
    }

    // =====================================
    // ДИАЛОГОВЫЕ ОКНА
    // =====================================
    private async Task OpenRenameDialogAsync(TemplateDefinition template)
    {
        var options = new DialogOptions { CloseOnEscapeKey = true };
        var parameters = new DialogParameters<UserInputDialog> { { x => x.Input, template.Name } };
        var dialog = await DialogService.ShowAsync<UserInputDialog>("Переименовать", parameters, options);
        var result = await dialog.Result;
        if (result == null || result.Canceled) return;
        template.Name = $"{result.Data}";
        PersistAsync().AndForget();
    }

    private async Task OpenDeleteDialogAsync(TemplateDefinition template)
    {
        var namePart = !string.IsNullOrWhiteSpace(template.Name) ? $" \"{template.Name}\"" : "";
        var message = $"Вы точно хотите удалить шаблон{namePart}?";

        var result = await DialogService.ShowMessageBox(
            "Удаление шаблона", message,
            yesText: "Удалить", cancelText: "Отмена");

        if (result != true) return;

        templates.Remove(template);
        PersistAsync().AndForget();
    }

    private async Task OpenDeleteDialogAsync(TemplateDefinition template, VariableDefinition variable)
    {
        if (!string.IsNullOrWhiteSpace(variable.Name) || !string.IsNullOrWhiteSpace(variable.Expression))
        {
            var namePart = string.IsNullOrWhiteSpace(variable.Name) ? "" : $" {variable.Name}";
            var exprPart = string.IsNullOrWhiteSpace(variable.Expression) ? "" : $": {variable.Expression}";
            var message = $"Вы точно хотите удалить переменную{namePart}{exprPart}?";

            var result = await DialogService.ShowMessageBox(
                "Удаление", message,
                yesText: "Удалить", cancelText: "Отмена");

            if (result != true) return;
        }

        template.Variables.Remove(variable);
        PersistAsync().AndForget();
    }

    // =====================================
    // ОБРАБОТЧИКИ UI СОБЫТИЙ
    // =====================================
    private async Task ClearAsync()
    {
        await (_fileUpload?.ClearAsync() ?? Task.CompletedTask);
        _fileNames.Clear();
        ClearDragClass();
    }

    private Task OpenFilePickerAsync()
        => _fileUpload?.OpenFilePickerAsync() ?? Task.CompletedTask;

    private void OnInputFileChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        var files = e.GetMultipleFiles();
        UploadTemplates(files.FirstOrDefault());
    }

    private void SetDragClass()
        => _dragClass = $"{DefaultDragClass.Replace("border-hidden ", "")} mud-border-primary";

    private void ClearDragClass()
        => _dragClass = DefaultDragClass;

    // =====================================
    // УТИЛИТЫ
    // =====================================
    double ToDouble(object raw)
    {
        return raw switch
        {
            int i => i,
            long l => l,
            double d => d,
            _ => throw new ArgumentException($"Неподдерживаемый тип аргумента: {raw.GetType()}")
        };
    }

    double ThrowLogged<T>(string message) where T : Exception
    {
        CalculationErrors.Add(message);

        var ctor = typeof(T).GetConstructor(new[] { typeof(string) });
        if (ctor == null)
            throw new InvalidOperationException($"У исключения {typeof(T).Name} отсутствует конструктор с параметром string.");

        throw (T)ctor.Invoke(new object[] { message });
    }
}