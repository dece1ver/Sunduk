@page "/dynamic-templates"
@using NCalc
@using Sunduk.PWA.Infrastructure.DynamicTemplatesData 
@using BlazorDownloadFile
@using System.Text.Json
@using System.Text
@using Sunduk.PWA.Infrastructure.Extensions
@using System.Threading
@using System.IO
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<style>
    .file-upload-input {
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
        z-index: 10;
        opacity: 0;
    }
</style>

<MudPopover Open="@(LocalStorageIsWorking || LocalStorageWorkCompleted)" AnchorOrigin="Origin.TopCenter">
    @if (LocalStorageIsWorking)
    {
        <MudProgressCircular Color="Color.Primary" Style="height:30px;width:30px;" Indeterminate="true" Class="mx-2 mt-2 mb-n0" />
    }
    @if (LocalStorageWorkCompleted)
    {
        <MudIcon Color="Color.Primary" Style="height:30px;width:30px;" Icon="@Icons.Material.Outlined.DoneAll" Class="mx-2 mt-2 mb-n0" />
    }
</MudPopover>



<MudToolBar Dense="true">
    <MudIconButton Variant="Variant.Text" Class="ma-0 pa-0" OnClick="AddTemplate" Icon="@Icons.Material.Outlined.PostAdd" />
    <MudFileUpload T="IReadOnlyList<IBrowserFile>" Class="flex-grow-1"
                   @ref="@_fileUpload"
                   OnFilesChanged="OnInputFileChanged"
                   AppendMultipleFiles
                   Hidden="@false"
                   InputClass="file-upload-input"
                   tabindex="-1"
                   @ondrop="@ClearDragClass"
                   @ondragenter="@SetDragClass"
                   @ondragleave="@ClearDragClass"
                   @ondragend="@ClearDragClass">
        <ActivatorContent>
            <MudPaper Outlined="true" Class="@_dragClass">
                <MudSpacer/>
                <MudFileUpload T="IBrowserFile" Accept=".json" FilesChanged="UploadTemplates">
                    <ActivatorContent>
                        <MudSpacer/>
                        <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Outlined.FileUpload" />
                    </ActivatorContent>
                </MudFileUpload>
            </MudPaper>
        </ActivatorContent>
    </MudFileUpload>
    <MudIconButton Variant="Variant.Text" Class="ma-0 pa-0" OnClick="DownloadTemplatesAsync" Icon="@Icons.Material.Outlined.FileDownload" />
    
</MudToolBar>
<MudDivider />

<MudDropContainer T="TemplateDefinition" Items="templates" ItemsSelector="@((_, _) => true)" ItemDropped="ItemUpdated">
    <ChildContent>
        <MudDropZone T="TemplateDefinition" AllowReorder="true">
            <MudSpacer />
        </MudDropZone>
    </ChildContent>
    <ItemRenderer>
        <MudExpansionPanel Gutters="false" Dense="true" ExpandedChanged="@(() => Calculate(context))" Class="ma-1">
            <TitleContent>
                <MudGrid Class="align-start d-flex ma-0 pa-0" Spacing="1">
                    <MudText>@context.Name</MudText>
                    <MudSpacer/>
                    <MudIconButton Variant="Variant.Text" Class="ma-0 pa-0" OnClick="() => OpenRenameDialogAsync(context)" Icon="@Icons.Material.Outlined.DriveFileRenameOutline" />
                    <MudIconButton Variant="Variant.Text" Class="ma-0 pa-0" OnClick="() => OpenDeleteDialogAsync(context)" Icon="@Icons.Material.Outlined.Delete" Color="Color.Error" />
                </MudGrid>
            </TitleContent>
            <ChildContent>
                <MudToolBar Dense="true">
                    <MudIconButton Variant="Variant.Text" Class="my-0 py-0" OnClick="() => { Calculate(context); PersistAsync().AndForget(); }" Icon="@Icons.Material.Outlined.Calculate" Color="Color.Primary" />
                    <MudSpacer />
                    <MudIconButton Variant="Variant.Text" Class="my-0 py-0" OnClick="() => { context.Variables.Add(new VariableDefinition()); PersistAsync().AndForget(); }" Icon="@Icons.Material.Outlined.PlaylistAdd" />
                        <MudDivider DividerType="DividerType.Inset"/>
                    <MudIconButton Variant="Variant.Text" Class="my-0 py-0" OnClick="() => DownloadTemplateAsync(context)" Icon="@Icons.Material.Outlined.Download" />
                    <MudFileUpload T="IBrowserFile" Accept=".json" FilesChanged="(f => UploadTemplate(f, context))">
                        <ActivatorContent>
                            <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Outlined.Upload" />
                        </ActivatorContent>
                    </MudFileUpload>

                </MudToolBar>
                <MudGrid Spacing="1" Class="ma-0">
                    <MudItem xs="6">
                        <MudTextField T="string"
                                      Label="Заготовка"
                                      Variant="Variant.Filled"
                                      @bind-Value="@context.Content"
                                      AutoGrow="true"
                                      Immediate="true"
                                      Lines="@(context.Content.Count(c => c == '\n') + 1)"
                                      Style="font-family: 'Roboto Mono', monospace; font-size: 12px;" />
                        <MudTextField T="string"
                                      Label="Результат"
                                      Variant="Variant.Filled"
                                      AutoGrow="true"
                                      Immediate="true"
                                      Lines="@(context.Result.Count(c => c == '\n') + 1)"
                                      Style="font-family: 'Roboto Mono', monospace; font-size: 12px;"
                                      Value="context.Result"
                                      ReadOnly="true" />
                    </MudItem>
                    <MudItem xs="6">
                        <MudField Label="Переменные" Variant="Variant.Filled" Underline="false" InnerPadding="false" FullWidth="true">
                            <MudList T="string" Dense="true">

                                @foreach (var variable in @context.Variables)
                                {
                                    <MudGrid Spacing="0" Class="ma-0 pa-0">
                                        <MudItem xs="3">
                                            <MudTextField Margin="Margin.Dense" @bind-Text="variable.Name" Label="Имя" Variant="Variant.Text" Style="font-family: 'Roboto Mono', monospace; font-size: 12px;" />
                                        </MudItem>
                                        <MudItem xs="8">
                                            <MudTextField Margin="Margin.Dense" @bind-Text="variable.Expression" Label="Значение" Variant="Variant.Text" Style="font-family: 'Roboto Mono', monospace; font-size: 12px;" />
                                        </MudItem>
                                        <MudItem xs="1">
                                            <MudIconButton Variant="Variant.Text" Class="mx-0 mt-2 pa-0" OnClick="() => OpenDeleteDialogAsync(context, variable)" Icon="@Icons.Material.Outlined.Delete" Color="Color.Error" />
                                        </MudItem>
                                    </MudGrid>
                                }
                            </MudList>
                        </MudField>
                    </MudItem>
                </MudGrid>
            </ChildContent>
        </MudExpansionPanel>
    </ItemRenderer>
</MudDropContainer>

@code {
    [Inject] public IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

    private const string DefaultDragClass = "rounded-lg border-2 border-dashed border-hidden align-start d-flex object-fill mud-theme-transparent ma-3";
    private string _dragClass = DefaultDragClass;
    private readonly List<string> _fileNames = new();
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;

    private async Task ClearAsync()
    {
        await (_fileUpload?.ClearAsync() ?? Task.CompletedTask);
        _fileNames.Clear();
        ClearDragClass();
    }

    private Task OpenFilePickerAsync()
        => _fileUpload?.OpenFilePickerAsync() ?? Task.CompletedTask;

    private void OnInputFileChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        var files = e.GetMultipleFiles();
        UploadTemplates(files.FirstOrDefault());
    }

    private void SetDragClass()
        => _dragClass = $"{DefaultDragClass.Replace("border-hidden ", "")} mud-border-primary";

    private void ClearDragClass()
        => _dragClass = DefaultDragClass;
    private readonly SemaphoreSlim _persistSemaphore = new(1, 1);
    public List<TemplateDefinition> templates { get; set; } = new();
    public bool LocalStorageIsWorking { get; set; }
    public bool LocalStorageWorkCompleted { get; set; }

    protected override async Task OnInitializedAsync()
    {
        templates = await LocalStorage.GetItemAsync<List<TemplateDefinition>>(nameof(templates))
                ?? new List<TemplateDefinition>();
        StateHasChanged();
    }

    private void AddTemplate()
    {
        templates.Add(new TemplateDefinition() { Name = $"Новый шаблон", Variables  = new() { new VariableDefinition() } } );
        PersistAsync().AndForget();
    }

    private async Task PersistAsync()
    {
        await _persistSemaphore.WaitAsync();
        try
        {
            LocalStorageWorkCompleted = false;
            LocalStorageIsWorking = true;
            StateHasChanged();

            await LocalStorage.SetItemAsync(nameof(templates), templates);

            StateHasChanged();
            LocalStorageWorkCompleted = true;
            LocalStorageIsWorking = false;
            StateHasChanged();

            await Task.Delay(1000);
            LocalStorageWorkCompleted = false;
            StateHasChanged();
        }
        finally
        {
            _persistSemaphore.Release();
        }
    }

    private async Task DownloadTemplatesAsync()
    {
        var json = JsonSerializer.Serialize(templates, new JsonSerializerOptions { WriteIndented = true });
        var bytes = Encoding.UTF8.GetBytes(json);
        await BlazorDownloadFileService.DownloadFile("sunduk-dt-all.json", bytes, "application/json");
    }

    private async Task DownloadTemplateAsync(TemplateDefinition template)
    {
        var json = JsonSerializer.Serialize(template, new JsonSerializerOptions { WriteIndented = true });
        var bytes = Encoding.UTF8.GetBytes(json);
        await BlazorDownloadFileService.DownloadFile($"sunduk-dt-{template.Name}.json", bytes, "application/json");
    }

    private void ItemUpdated(MudItemDropInfo<TemplateDefinition> dropItem)
    {
        if (dropItem is { Item: TemplateDefinition i })
        {
            templates.Remove(i);
            templates.Insert(dropItem.IndexInZone, i);
            StateHasChanged();
            PersistAsync().AndForget();
        }
    }


    private void Calculate(TemplateDefinition tpl)
    {
        try
        {
            var values = new Dictionary<string, double>();
            var maxIter = tpl.Variables.Count * 2; // Максимальное количество итераций
            var currentIter = 0;

            bool hasProgress;
            do
            {
                hasProgress = false;
                var initialCount = values.Count;

                foreach (var v in tpl.Variables)
                {
                    // Пропускаем уже вычисленные переменные
                    if (values.ContainsKey(v.Name)) continue;

                    try
                    {
                        var expr = new Expression(v.Expression.Replace(',', '.'), ExpressionOptions.IgnoreCaseAtBuiltInFunctions);

                        // Подставляем уже известные значения
                        foreach (var kv in values)
                            expr.Parameters[kv.Key] = kv.Value;

                        // Проверяем, есть ли ошибки (например, неопределенные переменные)
                        if (expr.HasErrors()) continue;

                        var raw = expr.Evaluate();
                        double d = raw switch
                        {
                            double dd => dd,
                            int ii => ii,
                            long ll => ll,
                            _ => throw new Exception($"Неподдерживаемый тип: {raw?.GetType()}")
                        };

                        values[v.Name] = d;
                    }
                    catch
                    {
                        // Если не удалось вычислить на этой итерации, попробуем на следующей
                        continue;
                    }
                }

                // Есть прогресс, если количество вычисленных переменных увеличилось
                hasProgress = values.Count > initialCount;
                currentIter++;

                // Защита от бесконечного цикла
                if (currentIter >= maxIter)
                {
                    // Проверяем, остались ли невычисленные переменные
                    var unresolved = tpl.Variables.Where(v => !values.ContainsKey(v.Name)).ToList();
                    if (unresolved.Any())
                    {
                        var unresolvedNames = string.Join(", ", unresolved.Select(v => $"{v.Name}: {v.Expression}"));
                        throw new Exception($"Не удалось вычислить переменные (возможно, циклическая зависимость или неопределенные переменные): {unresolvedNames}");
                    }
                    break;
                }

            } while (hasProgress && values.Count < tpl.Variables.Count);

            // Проверяем, все ли переменные были вычислены
            var notResolved = tpl.Variables.Where(v => !values.ContainsKey(v.Name)).ToList();
            if (notResolved.Any())
            {
                var notResolvedNames = string.Join(", ", notResolved.Select(v => $"{v.Name}: {v.Expression}"));
                throw new Exception($"Не удалось вычислить переменные: {notResolvedNames}");
            }

            // Выполняем подстановку в шаблон
            tpl.Result = System.Text.RegularExpressions.Regex
                .Replace(tpl.Content, @"\{(.*?)\}", m =>
                {
                    try
                    {
                        var sub = new Expression(m.Groups[1].Value.Replace(',', '.'), ExpressionOptions.IgnoreCaseAtBuiltInFunctions);
                        foreach (var kv in values)
                            sub.Parameters[kv.Key] = kv.Value;

                        if (sub.HasErrors())
                            return "[?]";

                        var r = sub.Evaluate();
                        return r is double x ? x.ToString("0.###").Replace(',', '.') :
                               r is int i ? i.ToString() :
                               r is long l ? l.ToString() :
                               r?.ToString() ?? "[?]";
                    }
                    catch
                    {
                        return "[?]";
                    }
                });
        }
        catch (Exception ex)
        {
            Snackbar.Configuration.PositionClass = Defaults.Classes.Position.TopCenter;
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private async Task OpenRenameDialogAsync(TemplateDefinition template)
    {
        var options = new DialogOptions { CloseOnEscapeKey = true };
        var parameters = new DialogParameters<UserInputDialog> { { x => x.Input, template.Name } };
        var dialog = await DialogService.ShowAsync<UserInputDialog>("Переименовать", parameters, options);
        var result = await dialog.Result;
        if (result == null || result.Canceled) return;
        template.Name = $"{result.Data}";
        PersistAsync().AndForget();
    }

    private async Task OpenDeleteDialogAsync(TemplateDefinition template)
    {
        var options = new DialogOptions { CloseOnEscapeKey = true };
        var parameters = new DialogParameters<ConfirmDialog> { { x => x.OkMessage, "Удалить" } };
        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Удаление", parameters, options);
        var result = await dialog.Result;
        if (result == null || result.Canceled) return;
        templates.Remove(template);
        PersistAsync().AndForget();
    }

    private async Task OpenDeleteDialogAsync(TemplateDefinition template, VariableDefinition variable)
    {
        bool? result = await DialogService.ShowMessageBox(
            "Удаление",
            $"Вы точно хотите удалить переменную{(!string.IsNullOrWhiteSpace(variable.Name) ? $" {variable.Name}" : "")}{(!string.IsNullOrWhiteSpace(variable.Expression) ? $": {variable.Expression}" : "")}?",
            yesText: "Удалить", cancelText: "Отмена");
        if (result != true) return;
        template.Variables.Remove(variable);
        PersistAsync().AndForget();
    }
    private async Task UploadTemplate(IBrowserFile file, TemplateDefinition template)
    {
        using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024);
        using var reader = new StreamReader(stream);
        var json = await reader.ReadToEndAsync();

        var loaded = JsonSerializer.Deserialize<TemplateDefinition>(json, new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        });

        if (loaded is null)
        {
            Snackbar.Add("Ошибка: не удалось загрузить шаблон из файла", Severity.Error);
            return;
        }
        template.Name = loaded.Name;
        template.Content = loaded.Content;
        template.Variables = loaded.Variables ?? new List<VariableDefinition>();
        template.Result = loaded.Result;
        PersistAsync().AndForget();
        StateHasChanged();
    }

    private async Task UploadTemplates(IBrowserFile file)
    {
        using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024);
        using var reader = new StreamReader(stream);
        var json = await reader.ReadToEndAsync();

        List<TemplateDefinition>? loaded = null;

        var options = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };

        try
        {
            // Пытаемся как список
            loaded = JsonSerializer.Deserialize<List<TemplateDefinition>>(json, options);
        }
        catch (JsonException)
        {
            // Игнорируем, пробуем как одиночный объект
        }

        if (loaded == null)
        {
            try
            {
                var single = JsonSerializer.Deserialize<TemplateDefinition>(json, options);
                if (single is not null)
                    loaded = new List<TemplateDefinition> { single };
            }
            catch (JsonException ex)
            {
                Snackbar.Add($"Ошибка чтения JSON: {ex.Message}", Severity.Error);
                return;
            }
        }

        if (loaded == null || loaded.Count == 0)
        {
            Snackbar.Add("Ошибка: не удалось загрузить ни одного шаблона из файла", Severity.Error);
            return;
        }

        if (templates.Any())
        {
            var result = await DialogService.ShowMessageBox(
                "Импорт шаблонов",
                $"Добавить шаблоны: {loaded.Count} шт. к существующим или заменить всё?",
                yesText: "Добавить", noText: "Заменить", cancelText: "Отмена");

            switch (result)
            {
                case true:
                    templates.AddRange(loaded);
                    break;
                case false:
                    templates = loaded;
                    break;
                default:
                    return;
            }
        }
        else
        {
            templates = loaded;
        }

        PersistAsync().AndForget();
        StateHasChanged();
    }
}
